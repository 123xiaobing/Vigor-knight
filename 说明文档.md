# 说明文档

## 游戏说明部分

### 玩家（挂载了玩家控制和武器切换脚本）

玩家移动：WASD

玩家动作变换：只有走动和死亡

玩家与一些触发器或者图层的碰撞：

与传送门图层碰撞

与地刺碰撞

与BOSS的技能碰撞	

### 地图生成

地图生成有两个脚本，一个脚本控制每个小房间的各种属性和方法，一个脚本控制整个场景的所有房间的生成



### 武器

一共有三把武器：手枪，步枪，狙击；武器随着鼠标的位置转动，右键技能，技能持续4s然后有6s冷却时间

手枪每0.5s发射一颗子弹，不消耗能量值；步枪每0.5s发射一颗子弹，技能状态下每0.2s发射一颗子弹，消耗两点能量值；狙击每1s发射一颗子弹，技能状态下每0.5s发射一颗子弹，消耗5点能量值

### 小地图

小地图中显示的是各个房间形状的预制体和与玩家绑定的一个标记点，当玩家走到某个房间，该房间的轮廓才会显示在小地图上，M键打开小地图，N键关闭小地图，小地图开启时间内玩家不能移动

### 敌人（没有花很多时间做）

敌人只做了猪，哥布林，和一个BOSS

猪的移动用的是一个A*寻路的插件，部分功能不适用，所以对插件的脚本有些修改。寻路功能是每一秒对整个地图进行扫描，找到可以到达的位置，计算出到达目标位置的路线，猪碰到玩家会对玩家造成伤害

哥布林只是实现了自身的一些属性，会左右移动，有生命值等

BOSS实现了三种技能，从中心点向周围发射子弹，对玩家造成伤害

### 门

每次玩家走到某个房间，玩家碰到房间区域的触发器，关门，2s后生成敌人，每个房间的的敌人数量是该房间距离初始房间步数的2倍，当该房间的敌人数量为0时，门打开

### 宠物

宠物的移动和猪的移动同样的原理，当宠物距离玩家很远时，宠物瞬移追上玩家

### UI

开始界面有游戏玩法说明和开始按钮

游戏过程中有玩家的生命值，护甲值，能量值和暂停按钮



## 代码说明部分

### 主要且有功能的脚本

一些比较基本的功能实现脚本没有粘过来，部分脚本在学习过程中出现了一些问题被废弃但是没有删掉

#### 玩家脚本

玩家脚本中比较特殊的是会在游戏运行时修改玩家预制体的位置，因为要用寻路插件，寻路插件挂在敌人身上，敌人是在游戏进行中生成的，所以没有别的办法但是修改预制体确实不好。

在BOSS攻击中玩家碰到BOSS发射的子弹会造成好几次伤害，所以我用了一个bool值每0.1s将玩家的可攻击性进行刷新



```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class playerControl : MonoBehaviour
{
    public Rigidbody2D rb;
    private Collider2D coll;
    public Animator anim;

    [Header("玩家属性")]
    public int healthNum;
    public int MaxHealth;
    public int magicNum;
    public int MaxMagic;
    public int defenceNum;//三秒+1
    public int MaxDefence;

    long stopTime = -3;

    public float speed;
    public float speed1;
    Vector2 movement;

    public Transform playerPrefab;//用于记录玩家的位置，让怪物实现自动寻路

    public LayerMask TransferGate;//记录传送门的图层

    bool beAttacked = true;//记录是否被BOSS攻击
    float beAttackedDuringTime = 0.1f;//每0.1s将beAttacked改成true;
    float NowTime;

    public GameObject NextLevelBtn;

    void Start()
    {
        NowTime = Time.realtimeSinceStartup;
        
        rb = GetComponent<Rigidbody2D>();
        coll = GetComponent<Collider2D>();
        anim = GetComponent<Animator>();
        
        speed1 = speed;
        
        healthNum = MaxHealth;
        magicNum = MaxMagic;
        defenceNum = MaxDefence;
    }

    
    void Update()
    {
        
        movement.x = Input.GetAxisRaw("Horizontal");
        movement.y = Input.GetAxisRaw("Vertical");

        if(movement.x!=0)
        {
            rb.transform.localScale = new Vector3(movement.x, 1, 1);
        }

        switchAnim();

        DefenceNumAdd();//护甲自动回复
        
        Transfer();//传送


        //每隔0.1s将beAttacked重置
        if(Time.realtimeSinceStartup-NowTime>beAttackedDuringTime)
        {
            beAttacked = true;
            NowTime += beAttackedDuringTime;
        }

    }
    private void FixedUpdate()
    {
        playerPrefab.position = transform.position;
        rb.MovePosition(rb.position + movement * speed * Time.fixedDeltaTime);
    }

    public void switchAnim()
    {
        anim.SetFloat("running", movement.magnitude-0.1f);
    }

    //护甲自动回复
    public void DefenceNumAdd()
    {
        if (defenceNum == MaxDefence)
            stopTime = (long)Time.time;

        if(Time.time-stopTime>3f&&defenceNum<MaxDefence)
        {
            stopTime += 3;
            defenceNum += 1;
        }
    }

    //传送门
    void Transfer()
    {
        if(coll.IsTouchingLayers(TransferGate))
        {
            //按E提示进入下一关
            if (Input.GetKey(KeyCode.E))
                NextLevelBtn.SetActive(true);
                
        }
    }

    int temp;//记录BOSS伤害消除护甲后剩余的伤害
    //BOSS伤害
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if(collision.gameObject.tag=="BossSkill")//BOSS的第一个大招每个“子弹”3点伤害
        {
            collision.gameObject.SetActive(false);

                if (defenceNum > 0)
                {
                    if (defenceNum >= 3&& beAttacked)
                    {
                        defenceNum -= 3;
                        Debug.Log("生命值-3");
                        beAttacked = false;
                    }

                    if (defenceNum < 3&& beAttacked)
                    {
                        temp = 3 - defenceNum;
                        defenceNum = 0;
                        healthNum -= temp;
                        Debug.Log("生命值-" + temp);
                        if (healthNum <= 0)
                        {
                            healthNum = 0;//刷新生命值
                            anim.SetBool("die", true);
                            Time.timeScale = 0;
                        }
                        beAttacked = false;
                    }
                }
                if (defenceNum <= 0&& beAttacked)
                {
                    healthNum -= 3;
                    Debug.Log("生命值又-3");
                    if (healthNum <= 0)
                    {
                        healthNum = 0;//刷新生命值
                        anim.SetBool("die", true);
                        Time.timeScale = 0;

                    }
                    beAttacked = false;
                }
        }

        //地刺陷阱
        if (collision.gameObject.tag == "SandBox")
        {
            if (defenceNum > 0)
                defenceNum--;
            if (defenceNum <= 0)
            {
                healthNum--;
                if (healthNum <= 0)
                {
                    anim.SetBool("die", true);
                    Time.timeScale = 0;
                }
            }
        }
    }
}

```

#### 每个房间的脚本

这个脚本和房间管理器脚本结合生成一整个场景。每个房间的生成是预先有所有的房间形状预制体，在房间管理器脚本中通过判断已经生成的房间周围有没有房间来确定这个方位有没有门，再将门的数量传进房间管理器中选择要生成的房间的形状，依次生成所有的房间。

在这个脚本里实现了门的开合，人物进入房间碰到房间区域触发器实现关门和生成敌人等；奖励盒子的生成，奖励盒子是在该房间任何一个位置生成，生成后将盒子的位置返回，传入GetAwards()方法中，getawards方法主要是生成能量珠，能量珠追随玩家(用的寻路插件)，能量珠销毁。

还实现了敌人的生成和传送门以及BOSS的生成。如果不是初始房间，房间的SpriteRenderer属性的颜色不是红色(在房间管理器生成房间时将最后一个房间的该属性设置为了红色)，就生成敌人；如果房间的SpriteRenderer属性颜色是红色而且不是最后一小关，就生成传送门，如果是最后一小关的最后一个房间，就生成一个BOSS

```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class Room : MonoBehaviour
{
    public static Room instance;

    private void Awake()
    {
        instance = this;
    }


    public GameObject doorLeft, doorRight, doorUp, doorDown;

    public bool roomLeft, roomRight, roomUp, roomDown;//判断上下左右是否有房间

    public GameObject nextLevelDoor;//传送门
    
    int nextLevelDoorNum;//记录个数，防止多次生成

    public int stepToStart;//决定房间的难易程度

    public int enemyNum;//判断敌人数量,在门的控制里调用，控制门的开关

    public Text text;

    public int doorNum;

    public Collider2D coll;

    private doorControl dc;

    private playerControl player;

    private RoomGenerator rg;

    private SpriteRenderer sr;
    
    Vector2 MinPos;//房间最左侧的位置
    Vector2 MaxPos;//房间最右侧的位置


    //随机生成敌人
    public List<GameObject> enemys = new List<GameObject>();
    bool noInitedEnemy=true;

    
    //随机生成宝箱
    public GameObject[] Awards;//0是每个房间的奖励盒子
    public bool noInitedBox=true;
    GameObject Box;

    //生成奖励物品
    public GameObject[] AwardObjects;//0是能量值
    bool noInitedAwardObject1=true;

    //存放BOSS预制体
    public GameObject BOSSPrefab;

    //记录当前场景编号，最后一个场景的最后一个房间生成BOSS而不是传送门
    int index;

    void Start()
    {
        dc = GetComponentInChildren<doorControl>();
        sr = gameObject.GetComponent<SpriteRenderer>();
        player = GameObject.Find("Player").GetComponent<playerControl>();
        rg = GameObject.Find("RoomGenerator").GetComponent<RoomGenerator>();
        //每个房间的长为16，宽为8
        MinPos = new Vector2(transform.position.x - 8f, transform.position.y);
        MaxPos = new Vector2(transform.position.x + 8f, transform.position.y);



        doorLeft.SetActive(roomLeft);
        doorRight.SetActive(roomRight);
        doorUp.SetActive(roomUp);
        doorDown.SetActive(roomDown);

        enemyNum = 2 * stepToStart;
        // Debug.Log("这是怪物数量"+enemyNum);

        //获取当前场景编号，最后一个场景的最后一个房间生成BOSS而不是传送门
        index = SceneManager.GetActiveScene().buildIndex;


    }

    
    void Update()
    {
       // Debug.Log(player.transform.position.x);
       // Debug.Log(InitAwards() + "这是奖励盒子的位置");
    }
    private void FixedUpdate()
    {
        if(noInitedBox)
        {
            BoxPos(out Box);
        }

        GetAwards(Box);
    }

    public void UpdateRoom(float xOffset,float yOffset)
    {
        stepToStart = (int)(Mathf.Abs(transform.position.x / xOffset) + Mathf.Abs(transform.position.y / yOffset));
        text.text = stepToStart.ToString();
        if (roomUp)
        {
            doorNum++;
           // Debug.Log("Up");
        }
        if (roomDown)
        {
            doorNum++;
           // Debug.Log("Down");
        }
        if (roomLeft)
        {
            doorNum++;
            //Debug.Log("Left");
        }
        if (roomRight)
        {
            doorNum++;
            //Debug.Log("Right");
        }

    }

    public void DoorStateChange()
    {
        if (enemyNum == 0) 
        { 
            dc.OpenDoors();//开门
        }
        

    }

    public void BoxPos(out GameObject Box)
    {
        if (enemyNum == 0 && stepToStart != 0 && noInitedBox)
        {
            Debug.Log("生成了盒子");
            Box = Instantiate(Awards[0], new Vector2(Random.Range(MinPos.x, MaxPos.x), Random.Range(MinPos.y - 3f, MinPos.y + 3f)), Quaternion.identity);
            noInitedBox = false;
            //Debug.Log(Box.transform.position + "这是盒子的位置");
        }
        else Box = null;

    }


    public void GetAwards(GameObject Box)//在生成奖励盒子周边的一定区域内打开奖励盒子
    {
        if (Box != null)
        {
            if (Mathf.Abs(Box.transform.position.x - player.transform.position.x) < 1f && Mathf.Abs(Box.transform.position.y - player.transform.position.y) < 1f && noInitedAwardObject1)
            {
                Debug.Log("即将生成宝珠");

                Destroy(Box.transform.gameObject);//生成宝珠的同时，销毁盒子

                GameObject gems= Instantiate(AwardObjects[0], new Vector2(Random.Range(Box.transform.position.x - 0.5f, Box.transform.position.x + 0.5f), Random.Range(Box.transform.position.y - 0.5f, Box.transform.position.y + 0.5f)), Quaternion.identity);
                
                noInitedAwardObject1 = false;

                //吸引效果用的插件

                //接触到玩家之后，能量珠销毁
                if (Mathf.Abs(gems.transform.position.x- player.transform.position.x)<2f&&Mathf.Abs(gems.transform.position.y - player.transform.position.y)<2f)
                {
                    Debug.Log("距离可以了");
                    Destroy(gems.transform.gameObject,0.2f);
                    //玩家吃到能量珠，蓝条恢复
                    if(player.magicNum<player.MaxMagic)
                        player.magicNum += 16;
                    if (player.magicNum >= player.MaxMagic)
                        player.magicNum = player.MaxMagic;
                }

            }
        }
    }

    //生成怪物的方法
    void inite()
    {
        for (int i = 0; i < enemyNum; i++)
        {
            int index = Random.Range(0, enemys.Count);//记录生成哪个怪物

            GameObject enemy = Instantiate(enemys[index], new Vector2(Random.Range(MinPos.x+1f, MaxPos.x-1f), Random.Range(MinPos.y - 3f, MinPos.y + 3f)), Quaternion.identity);

            enemy.GetComponent<EnemyAI>().room = this;
        }
    }

    //生成BOSS的方法
    void initBoss()
    {
        Instantiate(BOSSPrefab, transform.position, Quaternion.identity);
    }

    //生成怪物
    private void OnTriggerEnter2D(Collider2D collision)
    {
        //获取的是房间的颜色，判断是不是最后一个房间,最后一个房间不生成怪物
        if (stepToStart != 0&&noInitedEnemy&&sr.color!=Color.red)
        {
            Invoke("inite", 1f);//进入房间后延时一秒生成怪物
            
            noInitedEnemy = false;

            if (enemyNum > 0)
            {
                dc.CloseTheDoor();
                Debug.Log("enemyNum=" + enemyNum);
            }
           
        }

        //生成传送门
        if(sr.color==Color.red&&nextLevelDoorNum==0&&index!=5)
        {
            Instantiate(nextLevelDoor, transform.position, Quaternion.identity);
            nextLevelDoorNum += 1;
        }

        //生成BOSS
        if(sr.color == Color.red&&noInitedEnemy && index== 5)
        {
            //生成BOSS
            Invoke("initBoss", 1.5f);
            noInitedEnemy = false;
        }

    }


}
```

#### 房间管理器脚本

先生成房间轮廓预制体，用枚举随机选择一个方向，如果该方向检测到已经生成房间了，就改变方向直到找到能生成房间的方向生成房间再结合上一个脚本决定生成的房间的形状

找最后的房间：在上面的脚本记录当前房间到初始房间的步数，把所有步数最大的房间放到一个链表，再找次大的放到一个链表，再从最大的和次大的里面找单向门的房间，如果有单向门的，就在单向门的里面随机选择一个当最后一个房间，如果没有单向门的，就从步数最大的房间链表里随机选择一个当作最终房间，并把最终房间的颜色改成红色作为记录。

```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class RoomGenerator : MonoBehaviour
{
    public enum Direction { up,down,left,right };
    public Direction direction;

    [Header("房间信息")]
    public GameObject roomPrefab;
    public int roomNumber;
    public Color startColor, endColor;//开始和结尾房间的颜色
    public GameObject endRoom;
    
    [Header("位置控制")]
    public Transform generaterPoint;
    public float xOffset;//x方向位移
    public float yOffset;//y方向位移
    public LayerMask RoomLayer;
    
    public int maxStep;
    public List<Room> rooms = new List<Room>();//链表用来保存新生成的房间
    
    List<GameObject> farRooms = new List<GameObject>();
    List<GameObject> lessFarRooms = new List<GameObject>();
    List<GameObject> oneWayRooms = new List<GameObject>();
    
    public WallType walltype;
    
    //记录物理距离最远房间的距离
    float furthest;
    //记录物理距离最远的房间，生成传送门或者BOSS
    public int furthestRoomNum = 0;


    void Start()
    {
        for (int i = 0; i < roomNumber; i++)
        {
            rooms.Add(Instantiate(roomPrefab, generaterPoint.position, Quaternion.identity).GetComponent<Room>());
    
            //改变point位置
            ChangePointPosition();
        }


​        
​        

        furthest = Mathf.Abs(rooms[1].transform.position.x - rooms[0].transform.position.x) + Mathf.Abs(rooms[1].transform.position.y - rooms[0].transform.position.y);
    
        for(int i=2;i<roomNumber;i++)
        {
            float temp= Mathf.Abs(rooms[i].transform.position.x - rooms[0].transform.position.x) + Mathf.Abs(rooms[i].transform.position.y - rooms[0].transform.position.y);
            if(temp>furthest)
            {
                furthest = temp;
                furthestRoomNum = i;
            }
        }
    
        Debug.Log("最远房间号是" + furthestRoomNum);
    
        rooms[0].GetComponent<SpriteRenderer>().color = startColor;
    
        endRoom = rooms[0].gameObject;


        //找到最后房间
        foreach(var room in rooms)
        {
            SetupRoom(room, room.transform.position);
        }
        FindEndRoom();
        endRoom.GetComponent<SpriteRenderer>().color = endColor;


    }
    
    // Update is called once per frame
    void Update()
    {
        
    }
    public void ChangePointPosition()
    {
        do
        {
            direction = (Direction)Random.Range(0, 4);//运用枚举随机生成
    
            switch (direction)
            {
                case Direction.up:
                    generaterPoint.position += new Vector3(0, yOffset, 0);
                    break;
                case Direction.down:
                    generaterPoint.position += new Vector3(0, -yOffset, 0);
                    break;
                case Direction.left:
                    generaterPoint.position += new Vector3(-xOffset, 0, 0);
                    break;
                case Direction.right:
                    generaterPoint.position += new Vector3(xOffset, 0, 0);
                    break;
            }
        } while (Physics2D.OverlapCircle(generaterPoint.position,0.2f,RoomLayer));
    }
    
    public void SetupRoom(Room newRoom,Vector3 roomPosition)
    {
        newRoom.roomUp = Physics2D.OverlapCircle(roomPosition + new Vector3(0, yOffset, 0), 0.1f, RoomLayer);
        newRoom.roomDown = Physics2D.OverlapCircle(roomPosition + new Vector3(0, -yOffset, 0), 0.1f, RoomLayer);
        newRoom.roomLeft = Physics2D.OverlapCircle(roomPosition + new Vector3(-xOffset, 0, 0), 0.1f, RoomLayer);
        newRoom.roomRight = Physics2D.OverlapCircle(roomPosition + new Vector3(xOffset, 0, 0), 0.1f, RoomLayer);
                
        newRoom.UpdateRoom(xOffset,yOffset);


​        

        switch(newRoom.doorNum)
        {
            case 1:
                if(newRoom.roomUp)
                    Instantiate(walltype.singleU,roomPosition,Quaternion.identity);
                if(newRoom.roomDown)
                    Instantiate(walltype.singleD,roomPosition,Quaternion.identity);
                if(newRoom.roomLeft)
                    Instantiate(walltype.singleL,roomPosition,Quaternion.identity);
                if(newRoom.roomRight)
                    Instantiate(walltype.singleR,roomPosition,Quaternion.identity);
                break;
            case 2:
                if(newRoom.roomLeft&&newRoom.roomUp)
                    Instantiate(walltype.doubleUL,roomPosition,Quaternion.identity);
                if(newRoom.roomUp&&newRoom.roomRight)
                    Instantiate(walltype.doubleUR,roomPosition,Quaternion.identity);
                if(newRoom.roomRight&&newRoom.roomDown)
                    Instantiate(walltype.doubleRD,roomPosition,Quaternion.identity);
                if(newRoom.roomDown&&newRoom.roomLeft)
                    Instantiate(walltype.doubleLD,roomPosition,Quaternion.identity);
                if(newRoom.roomUp&&newRoom.roomDown)
                    Instantiate(walltype.doubleUD,roomPosition,Quaternion.identity);
                if(newRoom.roomLeft&&newRoom.roomRight)
                    Instantiate(walltype.doubleLR,roomPosition,Quaternion.identity);
                break;
            case 3:
                if(newRoom.roomLeft&&newRoom.roomUp&&newRoom.roomRight)
                    Instantiate(walltype.tripleLUR,roomPosition,Quaternion.identity);
                if(newRoom.roomUp&&newRoom.roomRight&&newRoom.roomDown)
                    Instantiate(walltype.tripleUDR,roomPosition,Quaternion.identity);
                if(newRoom.roomRight&&newRoom.roomDown&&newRoom.roomLeft)
                    Instantiate(walltype.tripleLDR,roomPosition,Quaternion.identity);
                if(newRoom.roomDown&&newRoom.roomLeft&&newRoom.roomUp)
                    Instantiate(walltype.tripleUDL,roomPosition,Quaternion.identity);
                break;
            case 4:
                if(newRoom.roomDown&&newRoom.roomLeft&&newRoom.roomUp&&newRoom.roomRight)
                Instantiate(walltype.fourDoors,roomPosition,Quaternion.identity);
                break;    
        }
    }
    
    public void FindEndRoom()
    {
        for (int  i = 0;  i < rooms.Count;  i++)
        {
            if (rooms[i].stepToStart > maxStep)
                maxStep = rooms[i].stepToStart;
        }
    
        //获得房间的最大值和次大值
        foreach (var room in rooms)
        {
            if (room.stepToStart == maxStep)
                farRooms.Add(room.gameObject);
            if (room.stepToStart == maxStep - 1)
                lessFarRooms.Add(room.gameObject);
        }
    
        for (int i = 0; i < farRooms.Count; i++)
        {
            if (farRooms[i].GetComponent<Room>().doorNum == 1)
                oneWayRooms.Add(farRooms[i]);
        }
    
        for (int i = 0; i < lessFarRooms.Count; i++)
        {
            if (lessFarRooms[i].GetComponent<Room>().doorNum == 1)
                oneWayRooms.Add(lessFarRooms[i]);
        }
    
        if(oneWayRooms.Count!=0)
        {
            endRoom = oneWayRooms[Random.Range(0, oneWayRooms.Count)];
        }
        else
        {
            endRoom = farRooms[Random.Range(0, farRooms.Count)];
        }
    }

}

[System.Serializable]
public class WallType
{
    public GameObject singleL,singleR,singleU,singleD,
                      doubleUL,doubleUR,doubleUD,doubleLR,doubleLD,doubleRD,
                      tripleLUR,tripleLDR,tripleUDL,tripleUDR,
                      fourDoors;


}
```

#### 门的控制脚本

```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class doorControl : MonoBehaviour
{
    public GameObject doorL, doorR, doorU, doorD;

    public Collider2D checkColl;

    public playerControl player;

    public Room room;

    private void Start()
    {
        //room = GameObject.Find("Room").GetComponent<Room>();

        Debug.Log("开始");
        doorL.SetActive(false);
        doorR.SetActive(false);
        doorU.SetActive(false);
        doorD.SetActive(false);
    }


    public void OpenDoors()//实现开门
    {
        
        doorL.SetActive(false);
        doorR.SetActive(false);
        doorU.SetActive(false);
        doorD.SetActive(false);
    }

    public void CloseTheDoor()//实现关门
    {
        Debug.Log("关门");
        if (room.roomLeft)
            doorL.SetActive(true);
        if (room.roomRight)
            doorR.SetActive(true);
        if (room.roomUp)
            doorU.SetActive(true);
        if (room.roomDown)
            doorD.SetActive(true);

    }

}
```

地刺控制脚本

地刺每三秒进行一次循环

```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SandBoxControl : MonoBehaviour
{
    float showTime = 3f;//地刺出现的时间
    float disappearTime = 3f;//地刺消失的时间

    public GameObject[] sandBox; 

    float nowTime;
    private void Start()
    {
        nowTime = Time.time;
        
    }

    void Update()
    {
        if (Time.time - nowTime > showTime)
        {
            if (sandBox[0].activeSelf==true)
            {
                for (int i = 0; i < sandBox.Length; i++)
                {

                    sandBox[i].gameObject.SetActive(false);

                }
                nowTime += showTime;
            }
            else
            {
                for (int i = 0; i < sandBox.Length; i++)
                {
                    sandBox[i].gameObject.SetActive(true);
                }
                nowTime += disappearTime;
            }
                
        }


    }
}

```

#### BOSS的大招

boss大招形式都是一样的，主要是循环

```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Skillcontrol : MonoBehaviour
{
    [SerializeField] float speed;
    public GameObject[] skill_1Balls;
    float skillStopTime1=4.5f;//BOSS第一个大招的间隔时间
    float nowTime1;//记录当前的时间

    public GameObject[] skill_2Balls;
    float skillStopTime2 =4.5f;
    float nowTime2;

    public GameObject[] skill_3Balls;
    float skillStopTime3 = 4.5f;
    float stopEachBall = 0.5f;//每个子弹发射后0.2s下一个子弹再发射
    float nowTime3;
    private void Start()
    {
        nowTime1 = Time.time;
        nowTime2 = Time.time+2.5f;
        nowTime3 = Time.time + 4f;
    }

    //生成BOSS时释放一次大招1
    //之后每4.5s再释放一次大招1

    //开始放第二个大招

    private void FixedUpdate()
    {
       //大招一
            for (int i = 0; i < 12; i++)//将大招发射出去
            {
                if (skill_1Balls[i])
                    skill_1Balls[i].GetComponent<Rigidbody2D>().velocity = new Vector2(Mathf.Cos(30 * i) * speed, Mathf.Sin(30 * i) * speed);
            }
            if(Time.time-nowTime1>skillStopTime1)
            {
                for (int i = 0; i < 12; i++)
                {
                    if (skill_1Balls[i])
                    {
                        skill_1Balls[i].gameObject.SetActive(false);
                        skill_1Balls[i].gameObject.transform.position = transform.position;
                    }
                }
                for (int i = 0; i < 12; i++)//将大招发射出去
                {
                    skill_1Balls[i].gameObject.SetActive(true);
                    if (skill_1Balls[i])
                        skill_1Balls[i].GetComponent<Rigidbody2D>().velocity = new Vector2(Mathf.Cos(30 * i) * speed, Mathf.Sin(+ 30 * i) * speed);
                }
                nowTime1 += skillStopTime1;
            }

        //大招二
        for (int i = 0; i < 12; i++)
        {
            if (skill_2Balls[i])
                skill_2Balls[i].GetComponent<Rigidbody2D>().velocity = new Vector2(Mathf.Cos(25 + 30 * i) * speed, Mathf.Sin(25 + 30 * i) * speed);
        }
        if (Time.time - nowTime2 > skillStopTime2)
        {
            for (int i = 0; i < 12; i++)
            {
                if (skill_2Balls[i])
                {
                    skill_2Balls[i].gameObject.SetActive(false);
                    skill_2Balls[i].gameObject.transform.position = transform.position;
                }
            }
            for (int i = 0; i < 12; i++)//将大招发射出去
            {
                skill_2Balls[i].gameObject.SetActive(true);
                if (skill_2Balls[i])
                    skill_2Balls[i].GetComponent<Rigidbody2D>().velocity = new Vector2(Mathf.Cos(25 + 30 * i) * speed, Mathf.Sin(25 + 30 * i) * speed);
            }
            nowTime2 += skillStopTime2;
        }


        //大招三
        for (int i = 0; i < 12; i++)
        {
            if (skill_3Balls[i])
                skill_3Balls[i].GetComponent<Rigidbody2D>().velocity = new Vector2(Mathf.Cos(50 + 30 * i) * speed, Mathf.Sin(50 + 30 * i) * speed);
        }
        if (Time.time - nowTime3 > skillStopTime3)
        {
            for (int i = 0; i < 12; i++)
            {
                if (skill_3Balls[i])
                {
                    skill_3Balls[i].gameObject.SetActive(false);
                    skill_3Balls[i].gameObject.transform.position = transform.position;
                }
            }
            for (int i = 0; i < 12; i++)//将大招发射出去
            {
                skill_3Balls[i].gameObject.SetActive(true);
                if (skill_3Balls[i]) 
                {
                    if (Time.time - nowTime3 > skillStopTime3 + stopEachBall)
                    {
                        skill_3Balls[i].GetComponent<Rigidbody2D>().velocity = new Vector2(Mathf.Cos(50 + 30 * i) * speed, Mathf.Sin(50 + 30 * i) * speed);
                        nowTime3 += stopEachBall;
                    }
                }
                    
            }
            nowTime3 += skillStopTime3;
        }

    }

}
```

#### 武器控制（以第二把武器为例）

武器的脚本里有改变枪的方向，子弹的发射，技能的控制

```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class WeaponTwo : MonoBehaviour
{
    public playerControl player;
    public float offset;
    public GameObject bulletPrefab;
    public Transform shotPoint;

    private float timeBtwShots;

    float startTimeBtwShots;
    public float startTimeBtwShots_Normal;
    public float startTimeBtwShots_Skill;

    public float superSkillTime;//技能持续时间
    public float superSkillIceTime;//技能冷却时间
    public bool isSuperSkill=false;//正在施行大招
    public bool isIce=false;//大招正在冷却
    float nowTime;//当前时间

    private void Start()
    {
        startTimeBtwShots = startTimeBtwShots_Normal;
    }

    private void Update()
    {

        transform.position = new Vector3(player.rb.position.x + 0.117f, player.rb.position.y - 0.189f, transform.position.z);

        SuperSkill();//大招
        if (timeBtwShots <= 0)
        {
            if (isPistolShooting()&&player.magicNum>=2)
            {
                Instantiate(bulletPrefab, shotPoint.position, transform.rotation);
                player.magicNum -= 2;
                timeBtwShots = startTimeBtwShots;
            }

        }
        else
        {
            timeBtwShots -= Time.deltaTime;
        }

    }
    public void FixedUpdate()
    {
        Vector3 difference = Camera.main.ScreenToWorldPoint(Input.mousePosition) - transform.position;
        float rotZ = Mathf.Atan2(difference.y, difference.x) * Mathf.Rad2Deg;
        if (player.transform.localScale.x == 1) transform.localScale = new Vector3(1, 1, 1);
        if (player.transform.localScale.x == -1) transform.localScale = new Vector3(-1, -1, 1);
        transform.rotation = Quaternion.Euler(transform.rotation.x, transform.rotation.y, rotZ + offset);
    }
    bool isPistolShooting()
    {
        bool shotting = false;
        if (Input.GetMouseButton(0))
        {
            shotting = true;
        }
        return shotting;
    }


    void SuperSkill()//技能
    {
        if(Input.GetMouseButton(1))
        {
            //技能释放
            if(!isSuperSkill)
            {
                isSuperSkill = true;
                nowTime = Time.time;
                startTimeBtwShots = startTimeBtwShots_Skill;
                Debug.Log("技能正在释放");
                
            }
        }
        if (isSuperSkill)
        {
            if (Time.time - nowTime > superSkillTime)
            {
                startTimeBtwShots = startTimeBtwShots_Normal;

                Debug.Log("技能正在冷却");

                if (!isIce)
                {
                    isIce = true;
                    Invoke("IceSkill", superSkillIceTime);
                    
                }
            }
           
        }
       
    }

    void IceSkill()
    {
        Debug.Log("技能冷却结束");
        isSuperSkill = false;
        isIce = false;
    }
}
```

#### 武器切换

```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class WeaponSystem : MonoBehaviour
{
    public GameObject[] Weapons;//武器列表
    public GameObject[] Bullets;//子弹列表


    void Start()
    {
        Weapons[0].SetActive(true);
        Weapons[1].SetActive(false);
        Weapons[2].SetActive(false);
    }

   
    void Update()
    {
        if(Input.GetKeyDown(KeyCode.Alpha1))//摁几号键就切换几号武器和几号子弹
        {
            ChangeToOne();
        }
        if(Input.GetKeyDown(KeyCode.Alpha2))
        {
            ChangeToTwo();
        }
        if(Input.GetKeyDown(KeyCode.Alpha3))
        {
            ChangeToThree();
        }

    }

    void ChangeToOne()
    {
        Weapons[0].SetActive(true);
        Weapons[1].SetActive(false);
        Weapons[2].SetActive(false);
    }

    void ChangeToTwo()
    {
        Weapons[0].SetActive(false);
        Weapons[1].SetActive(true);
        Weapons[2].SetActive(false);
    }

    void ChangeToThree()
    {
        Weapons[0].SetActive(false);
        Weapons[1].SetActive(false);
        Weapons[2].SetActive(true);
    }
}
```

## 游戏中实现的功能

​      实现一个骑士角色，初始携带破旧的手枪，用WSAD控制角色八向移动，鼠标移动控制人物的瞄准方向，左键开火，右键技能。

​      1-1到1-5的五个小关。

​	   击杀一个房间的所有怪物后会*生成一个奖励箱子*。(记录房间内的敌人数量，敌人数量为0时生成奖励盒子)

​	   实现场景中可被破坏的木箱。(子弹碰撞到木箱之后Destroy)

​	   完整的UI界面，包含主界面，暂停游戏，返回主界面等常见功能。

​		随机生成地牢。(上面的每个房间的脚本和房间管理器脚本有说明实现方法)

​		Boss战

​	    小地图(添加了一个摄像机，当玩家进入一个房间后，所有玩家经过的房间的小地图会显示出来，M开启小地图,N关闭小地图)

​		若干种武器

​		实现哥布林、野猪两种怪物。实现基本的怪物AI。(寻路主要用的插件，不寻路的在怪物上挂标记点，在标记点之间移动)

​		枪械技能(计时，循环)

## 用到的插件

cinemachine，A*寻路插件



## 实习感想

十天实习时间，和工程实训时间差不多，不过确实比工程实训稍微肝，因为工程实训是全天都坐在那里，而实习是在上课之余搞，再加上这段时间事情有点多，所以游戏做的比较粗糙，代码的架构也不是很好，还有很多小毛病，但是这几天确实学了不少东西，如果没有参加实习，我可能在很长一段时间内都不会学习对象池(虽然没用上)，我也不会研究随机房间的生成，也不会认为随便修改预制体是一件很糟的事情，还有关于大招的循环和某些其他东西的循环逻辑等等。总之收获满满，感谢memo能给我这个实习机会。
